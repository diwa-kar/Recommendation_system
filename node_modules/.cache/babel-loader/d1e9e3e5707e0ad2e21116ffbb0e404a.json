{"ast":null,"code":"import _regeneratorRuntime from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _classCallCheck from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _toConsumableArray from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { Section as $6555104ff085bef4$re_export$Section, useCollection as $1BfjW$useCollection } from \"@react-stately/collections\";\nimport $1BfjW$react, { useRef as $1BfjW$useRef, useState as $1BfjW$useState, useCallback as $1BfjW$useCallback, useMemo as $1BfjW$useMemo } from \"react\";\nimport { useGridState as $1BfjW$useGridState, GridCollection as $1BfjW$GridCollection } from \"@react-stately/grid\";\nfunction $30561577df230a30$export$f61abf052f87399f(widths) {\n  return Array.from(widths).map(function (e) {\n    return e[1];\n  }).reduce(function (acc, cur) {\n    return acc + cur;\n  }, 0);\n}\nfunction $30561577df230a30$export$1994a077b98ee0d5(width) {\n  return width != null && (!isNaN(width) || String(width).match(/^(\\d+)(?=%$)/) !== null);\n}\nfunction $30561577df230a30$var$parseFractionalUnit(width) {\n  if (!width) return 1;\n  var match = width.match(/^(\\d+)(?=fr$)/);\n  // if width is the incorrect format, just deafult it to a 1fr\n  if (!match) {\n    console.warn(\"width: \".concat(width, \" is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')\"), 'defaulting to \\'1fr\\'');\n    return 1;\n  }\n  return parseInt(match[0], 10);\n}\nfunction $30561577df230a30$export$7bbad27896f7ae9f(width, tableWidth) {\n  if (typeof width === 'string') {\n    var match = width.match(/^(\\d+)(?=%$)/);\n    if (!match) throw new Error('Only percentages or numbers are supported for static column widths');\n    return tableWidth * (parseInt(match[0], 10) / 100);\n  }\n  return width;\n}\nfunction $30561577df230a30$export$59185c62a7544aa0(maxWidth, tableWidth) {\n  return maxWidth != null ? $30561577df230a30$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;\n}\nfunction $30561577df230a30$export$f556054ce4358701(minWidth, tableWidth) {\n  return minWidth != null ? $30561577df230a30$export$7bbad27896f7ae9f(minWidth, tableWidth) : 75;\n}\nfunction $30561577df230a30$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth) {\n  var fractions = dynamicColumns.reduce(function (sum, column) {\n    return sum + $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth);\n  }, 0);\n  var columns = dynamicColumns.map(function (column, index) {\n    var targetWidth = $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;\n    var delta = Math.max($30561577df230a30$export$f556054ce4358701(column.props.minWidth, tableWidth) - targetWidth, targetWidth - $30561577df230a30$export$59185c62a7544aa0(column.props.maxWidth, tableWidth));\n    return _objectSpread({}, column, {\n      index: index,\n      delta: delta\n    });\n  });\n  return columns;\n}\nfunction $30561577df230a30$var$findDynamicColumnWidths(dynamicColumns, availableSpace, tableWidth) {\n  var fractions = dynamicColumns.reduce(function (sum, col) {\n    return sum + $30561577df230a30$var$parseFractionalUnit(col.props.defaultWidth);\n  }, 0);\n  var columns = dynamicColumns.map(function (column) {\n    var targetWidth = $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth) * availableSpace / fractions;\n    var width = Math.max($30561577df230a30$export$f556054ce4358701(column.props.minWidth, tableWidth), Math.min(Math.floor(targetWidth), $30561577df230a30$export$59185c62a7544aa0(column.props.maxWidth, tableWidth)));\n    column.calculatedWidth = width;\n    availableSpace -= width;\n    fractions -= $30561577df230a30$var$parseFractionalUnit(column.props.defaultWidth);\n    return column;\n  });\n  return columns;\n}\nfunction $30561577df230a30$export$a870e6692ac5ccb2(dynamicColumns, availableSpace, tableWidth) {\n  var columns = $30561577df230a30$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);\n  columns.sort(function (a, b) {\n    return b.delta - a.delta;\n  });\n  columns = $30561577df230a30$var$findDynamicColumnWidths(columns, availableSpace, tableWidth);\n  columns.sort(function (a, b) {\n    return a.index - b.index;\n  });\n  return columns;\n}\nfunction $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {\n  var getDefaultWidth = props.getDefaultWidth,\n    _props$tableWidth = props.tableWidth,\n    defaultTableWidth = _props$tableWidth === void 0 ? null : _props$tableWidth;\n  var columns1 = state.columns;\n  var columnsRef = $1BfjW$useRef([]);\n  var tableWidth = $1BfjW$useRef(defaultTableWidth);\n  var isResizing = $1BfjW$useRef(null);\n  var startResizeContentWidth = $1BfjW$useRef();\n  var _$1BfjW$useState = $1BfjW$useState(new Map(columns1.map(function (col) {\n      return [col.key, 0];\n    }))),\n    _$1BfjW$useState2 = _slicedToArray(_$1BfjW$useState, 2),\n    columnWidths = _$1BfjW$useState2[0],\n    setColumnWidths = _$1BfjW$useState2[1];\n  var columnWidthsRef = $1BfjW$useRef(columnWidths);\n  var affectedColumnWidthsRef = $1BfjW$useRef([]);\n  var _$1BfjW$useState3 = $1BfjW$useState(new Set()),\n    _$1BfjW$useState4 = _slicedToArray(_$1BfjW$useState3, 2),\n    resizedColumns = _$1BfjW$useState4[0],\n    setResizedColumns = _$1BfjW$useState4[1];\n  var resizedColumnsRef = $1BfjW$useRef(resizedColumns);\n  var _$1BfjW$useState5 = $1BfjW$useState(null),\n    _$1BfjW$useState6 = _slicedToArray(_$1BfjW$useState5, 2),\n    currentlyResizingColumn = _$1BfjW$useState6[0],\n    setCurrentlyResizingColumn = _$1BfjW$useState6[1];\n  function setColumnWidthsForRef(newWidths) {\n    columnWidthsRef.current = newWidths;\n    // new map so that change detection is triggered\n    setColumnWidths(newWidths);\n  }\n  /*\n  returns the resolved column width in this order:\n  previously calculated width -> controlled width prop -> uncontrolled defaultWidth prop -> dev assigned width -> default dynamic width\n  */\n  var getResolvedColumnWidth = $1BfjW$useCallback(function (column) {\n    var columnProps = column.props;\n    var _width, ref, ref1;\n    return (resizedColumns === null || resizedColumns === void 0 ? void 0 : resizedColumns.has(column.key)) ? columnWidthsRef.current.get(column.key) : (ref1 = (ref = (_width = columnProps.width) !== null && _width !== void 0 ? _width : columnProps.defaultWidth) !== null && ref !== void 0 ? ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(column.props)) !== null && ref1 !== void 0 ? ref1 : '1fr';\n  }, [getDefaultWidth, resizedColumns]);\n  var getStaticAndDynamicColumns = $1BfjW$useCallback(function (columns) {\n    return columns.reduce(function (acc, column) {\n      var width = getResolvedColumnWidth(column);\n      return $30561577df230a30$export$1994a077b98ee0d5(width) ? _objectSpread({}, acc, {\n        staticColumns: [].concat(_toConsumableArray(acc.staticColumns), [column])\n      }) : _objectSpread({}, acc, {\n        dynamicColumns: [].concat(_toConsumableArray(acc.dynamicColumns), [column])\n      });\n    }, {\n      staticColumns: [],\n      dynamicColumns: []\n    });\n  }, [getResolvedColumnWidth]);\n  var buildColumnWidths = $1BfjW$useCallback(function (affectedColumns, availableSpace) {\n    var widths = new Map();\n    var remainingSpace = availableSpace;\n    var _getStaticAndDynamicC = getStaticAndDynamicColumns(affectedColumns),\n      staticColumns = _getStaticAndDynamicC.staticColumns,\n      dynamicColumns = _getStaticAndDynamicC.dynamicColumns;\n    staticColumns.forEach(function (column) {\n      var width = getResolvedColumnWidth(column);\n      var w = $30561577df230a30$export$7bbad27896f7ae9f(width, tableWidth.current);\n      widths.set(column.key, w);\n      remainingSpace -= w;\n    });\n    // dynamic columns\n    if (dynamicColumns.length > 0) {\n      var newColumnWidths = $30561577df230a30$export$a870e6692ac5ccb2(dynamicColumns, remainingSpace, tableWidth.current);\n      var _iterator = _createForOfIteratorHelper(newColumnWidths),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var column = _step.value;\n          widths.set(column.key, column.calculatedWidth);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return widths;\n  }, [getStaticAndDynamicColumns, getResolvedColumnWidth]);\n  var prevColKeys = columnsRef.current.map(function (col) {\n    return col.key;\n  });\n  var colKeys = columns1.map(function (col) {\n    return col.key;\n  });\n  // if the columns change, need to rebuild widths.\n  if (prevColKeys.length !== colKeys.length || !colKeys.every(function (col, i) {\n    return col === prevColKeys[i];\n  })) {\n    columnsRef.current = columns1;\n    var widths = buildColumnWidths(columns1, tableWidth.current);\n    setColumnWidthsForRef(widths);\n  }\n  function setTableWidth(width) {\n    if (width && width !== tableWidth.current) {\n      tableWidth.current = width;\n      if (!isResizing.current) {\n        var _widths = buildColumnWidths(columns1, width);\n        setColumnWidthsForRef(_widths);\n      }\n    }\n  }\n  function onColumnResizeStart(column) {\n    setCurrentlyResizingColumn(column.key);\n    isResizing.current = true;\n    startResizeContentWidth.current = $30561577df230a30$export$f61abf052f87399f(columnWidthsRef.current);\n  }\n  function onColumnResize(column, width) {\n    var widthsObj = resizeColumn(column, width);\n    affectedColumnWidthsRef.current = widthsObj;\n    props.onColumnResize && props.onColumnResize(affectedColumnWidthsRef.current);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function onColumnResizeEnd(column) {\n    props.onColumnResizeEnd && isResizing.current && props.onColumnResizeEnd(affectedColumnWidthsRef.current);\n    setCurrentlyResizingColumn(null);\n    isResizing.current = false;\n    affectedColumnWidthsRef.current = [];\n    var widths = new Map(columnWidthsRef.current);\n    setColumnWidthsForRef(widths);\n  }\n  function resizeColumn(column1, newWidth) {\n    var boundedWidth = Math.max($30561577df230a30$export$f556054ce4358701(column1.props.minWidth, tableWidth.current), Math.min(Math.floor(newWidth), $30561577df230a30$export$59185c62a7544aa0(column1.props.maxWidth, tableWidth.current)));\n    // copy the columnWidths map and set the new width for the column being resized\n    var widths = new Map(columnWidthsRef.current);\n    widths.set(column1.key, boundedWidth);\n    // keep track of all columns that have been sized\n    resizedColumnsRef.current.add(column1.key);\n    setResizedColumns(resizedColumnsRef.current);\n    // get the columns affected by resize and remaining space\n    var resizeIndex = columnsRef.current.findIndex(function (col) {\n      return col.key === column1.key;\n    });\n    var affectedColumns = columnsRef.current.slice(resizeIndex + 1);\n    // we only care about the columns that CAN be resized, we ignore static columns.\n    var _getStaticAndDynamicC2 = getStaticAndDynamicColumns(affectedColumns),\n      dynamicColumns = _getStaticAndDynamicC2.dynamicColumns; // available space for affected columns\n    var availableSpace = columnsRef.current.reduce(function (acc, column, index) {\n      if (index <= resizeIndex || $30561577df230a30$export$1994a077b98ee0d5(getResolvedColumnWidth(column))) return acc - widths.get(column.key);\n      return acc;\n    }, tableWidth.current);\n    // merge the unaffected column widths and the recalculated column widths\n    var recalculatedColumnWidths = buildColumnWidths(dynamicColumns, availableSpace);\n    widths = new Map([].concat(_toConsumableArray(widths), _toConsumableArray(recalculatedColumnWidths)));\n    setColumnWidthsForRef(widths);\n    /*\n    when getting recalculated columns above, the column being resized is not considered \"recalculated\"\n    so we need to add it to the list of affected columns\n    */\n    var allAffectedColumns = [[column1.key, boundedWidth]].concat(_toConsumableArray(recalculatedColumnWidths)).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        width = _ref2[1];\n      return {\n        key: key,\n        width: width\n      };\n    });\n    return allAffectedColumns;\n  }\n  var ref2;\n  // This function is regenerated whenever columnWidthsRef.current changes in order to get the new correct ref value.\n  var getColumnWidth = $1BfjW$useCallback(function (key) {\n    return (ref2 = columnWidthsRef.current.get(key)) !== null && ref2 !== void 0 ? ref2 : 0;\n  }, [columnWidthsRef.current]);\n  var getColumnMinWidth = $1BfjW$useCallback(function (key) {\n    var columnIndex = columns1.findIndex(function (col) {\n      return col.key === key;\n    });\n    if (columnIndex === -1) return;\n    return $30561577df230a30$export$f556054ce4358701(columns1[columnIndex].props.minWidth, tableWidth.current);\n  }, [columns1]);\n  var getColumnMaxWidth = $1BfjW$useCallback(function (key) {\n    var columnIndex = columns1.findIndex(function (col) {\n      return col.key === key;\n    });\n    if (columnIndex === -1) return;\n    return $30561577df230a30$export$59185c62a7544aa0(columns1[columnIndex].props.maxWidth, tableWidth.current);\n  }, [columns1]);\n  return {\n    columnWidths: columnWidthsRef,\n    setTableWidth: setTableWidth,\n    onColumnResize: onColumnResize,\n    onColumnResizeStart: onColumnResizeStart,\n    onColumnResizeEnd: onColumnResizeEnd,\n    getColumnWidth: getColumnWidth,\n    getColumnMinWidth: getColumnMinWidth,\n    getColumnMaxWidth: getColumnMaxWidth,\n    currentlyResizingColumn: currentlyResizingColumn\n  };\n}\nvar $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$var$buildHeaderRows(keyMap, columnNodes) {\n  var columns = [];\n  var seen = new Map();\n  var _iterator2 = _createForOfIteratorHelper(columnNodes),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var column = _step2.value;\n      var parentKey = column.parentKey;\n      var col = [column];\n      while (parentKey) {\n        var parent = keyMap.get(parentKey);\n        // If we've already seen this parent, than it is shared\n        // with a previous column. If the current column is taller\n        // than the previous column, than we need to shift the parent\n        // in the previous column so it's level with the current column.\n        if (seen.has(parent)) {\n          parent.colspan++;\n          var _seen$get = seen.get(parent),\n            _column = _seen$get.column,\n            index = _seen$get.index;\n          if (index > col.length) break;\n          for (var _i3 = index; _i3 < col.length; _i3++) _column.splice(_i3, 0, null);\n          // Adjust shifted indices\n          for (var i1 = col.length; i1 < _column.length; i1++) if (_column[i1] && seen.has(_column[i1])) seen.get(_column[i1]).index = i1;\n        } else {\n          parent.colspan = 1;\n          col.push(parent);\n          seen.set(parent, {\n            column: col,\n            index: col.length - 1\n          });\n        }\n        parentKey = parent.parentKey;\n      }\n      columns.push(col);\n      column.index = columns.length - 1;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var maxLength = Math.max.apply(Math, _toConsumableArray(columns.map(function (c) {\n    return c.length;\n  })));\n  var headerRows = Array(maxLength).fill(0).map(function () {\n    return [];\n  });\n  // Convert columns into rows.\n  var colIndex = 0;\n  for (var _i = 0, _columns = columns; _i < _columns.length; _i++) {\n    var column1 = _columns[_i];\n    var _i2 = maxLength - 1;\n    var _iterator3 = _createForOfIteratorHelper(column1),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var item = _step3.value;\n        if (item) {\n          // Fill the space up until the current column with a placeholder\n          var row = headerRows[_i2];\n          var rowLength = row.reduce(function (p, c) {\n            return p + c.colspan;\n          }, 0);\n          if (rowLength < colIndex) {\n            var placeholder = {\n              type: 'placeholder',\n              key: 'placeholder-' + item.key,\n              colspan: colIndex - rowLength,\n              index: rowLength,\n              value: null,\n              rendered: null,\n              level: _i2,\n              hasChildNodes: false,\n              childNodes: [],\n              textValue: null\n            };\n            if (row.length > 0) {\n              row[row.length - 1].nextKey = placeholder.key;\n              placeholder.prevKey = row[row.length - 1].key;\n            }\n            row.push(placeholder);\n          }\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = item.key;\n            item.prevKey = row[row.length - 1].key;\n          }\n          item.level = _i2;\n          item.colIndex = colIndex;\n          row.push(item);\n        }\n        _i2--;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    colIndex++;\n  }\n  // Add placeholders at the end of each row that is shorter than the maximum\n  var i = 0;\n  var _iterator4 = _createForOfIteratorHelper(headerRows),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var row1 = _step4.value;\n      var _rowLength = row1.reduce(function (p, c) {\n        return p + c.colspan;\n      }, 0);\n      if (_rowLength < columnNodes.length) {\n        var _placeholder = {\n          type: 'placeholder',\n          key: 'placeholder-' + row1[row1.length - 1].key,\n          colspan: columnNodes.length - _rowLength,\n          index: _rowLength,\n          value: null,\n          rendered: null,\n          level: i,\n          hasChildNodes: false,\n          childNodes: [],\n          textValue: null,\n          prevKey: row1[row1.length - 1].key\n        };\n        row1.push(_placeholder);\n      }\n      i++;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return headerRows.map(function (childNodes, index) {\n    var row = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index: index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes: childNodes,\n      textValue: null\n    };\n    return row;\n  });\n}\nvar tmp = Symbol.iterator;\nvar $788781baa30117fa$export$596e1b2e2cf93690 = /*#__PURE__*/function (_$1BfjW$GridCollectio) {\n  _inherits($788781baa30117fa$export$596e1b2e2cf93690, _$1BfjW$GridCollectio);\n  _createClass($788781baa30117fa$export$596e1b2e2cf93690, [{\n    key: tmp,\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function value() {\n      return _regeneratorRuntime.wrap(function value$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            return _context.delegateYield(this.body.childNodes, \"t0\", 1);\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }, value, this);\n    })\n  }, {\n    key: \"getKeys\",\n    value: function getKeys() {\n      return this.keyMap.keys();\n    }\n  }, {\n    key: \"getKeyBefore\",\n    value: function getKeyBefore(key) {\n      var node = this.keyMap.get(key);\n      return node ? node.prevKey : null;\n    }\n  }, {\n    key: \"getKeyAfter\",\n    value: function getKeyAfter(key) {\n      var node = this.keyMap.get(key);\n      return node ? node.nextKey : null;\n    }\n  }, {\n    key: \"getFirstKey\",\n    value: function getFirstKey() {\n      var ref;\n      return (ref = _toConsumableArray(this.body.childNodes)[0]) === null || ref === void 0 ? void 0 : ref.key;\n    }\n  }, {\n    key: \"getLastKey\",\n    value: function getLastKey() {\n      var ref;\n      var rows = _toConsumableArray(this.body.childNodes);\n      return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this.keyMap.get(key);\n    }\n  }, {\n    key: \"at\",\n    value: function at(idx) {\n      var keys = _toConsumableArray(this.getKeys());\n      return this.getItem(keys[idx]);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return _toConsumableArray(this.body.childNodes).length;\n    }\n  }]);\n  function $788781baa30117fa$export$596e1b2e2cf93690(nodes, prev, opts) {\n    var _this;\n    _classCallCheck(this, $788781baa30117fa$export$596e1b2e2cf93690);\n    var rowHeaderColumnKeys = new Set();\n    var body;\n    var columns = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n      var rowHeaderColumn = {\n        type: 'column',\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    var rows = [];\n    var columnKeyMap = new Map();\n    var visit = function visit(node) {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n            if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return;\n        // do not go into childNodes\n      }\n      var _iterator5 = _createForOfIteratorHelper(node.childNodes),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var child = _step5.value;\n          visit(child);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    };\n    var _iterator6 = _createForOfIteratorHelper(nodes),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var node1 = _step6.value;\n        visit(node1);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    var headerRows = $788781baa30117fa$var$buildHeaderRows(columnKeyMap, columns);\n    headerRows.forEach(function (row, i) {\n      return rows.splice(i, 0, row);\n    });\n    _this = _possibleConstructorReturn(this, _getPrototypeOf($788781baa30117fa$export$596e1b2e2cf93690).call(this, {\n      columnCount: columns.length,\n      items: rows,\n      visitNode: function visitNode(node) {\n        node.column = columns[node.index];\n        return node;\n      }\n    }));\n    _this.columns = columns;\n    _this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    _this.body = body;\n    _this.headerRows = headerRows;\n    // Default row header column to the first one.\n    if (_this.rowHeaderColumnKeys.size === 0) _this.rowHeaderColumnKeys.add(_this.columns[(opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) ? 1 : 0].key);\n    return _this;\n  }\n  return $788781baa30117fa$export$596e1b2e2cf93690;\n}($1BfjW$GridCollection);\nvar $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {\n  ascending: 'descending',\n  descending: 'ascending'\n};\nfunction $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {\n  var _$1BfjW$useState7 = $1BfjW$useState(false),\n    _$1BfjW$useState8 = _slicedToArray(_$1BfjW$useState7, 2),\n    isKeyboardNavigationDisabled = _$1BfjW$useState8[0],\n    setKeyboardNavigationDisabled = _$1BfjW$useState8[1];\n  var _props$selectionMode = props.selectionMode,\n    selectionMode = _props$selectionMode === void 0 ? 'none' : _props$selectionMode;\n  var context = $1BfjW$useMemo(function () {\n    return {\n      showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== 'none',\n      selectionMode: selectionMode,\n      columns: []\n    };\n  }, [props.children, props.showSelectionCheckboxes, selectionMode]);\n  var collection = $1BfjW$useCollection(props, function (nodes, prev) {\n    return new $788781baa30117fa$export$596e1b2e2cf93690(nodes, prev, context);\n  }, context);\n  var _$1BfjW$useGridState = $1BfjW$useGridState(_objectSpread({}, props, {\n      collection: collection\n    })),\n    disabledKeys = _$1BfjW$useGridState.disabledKeys,\n    selectionManager = _$1BfjW$useGridState.selectionManager;\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: selectionManager,\n    showSelectionCheckboxes: props.showSelectionCheckboxes || false,\n    sortDescriptor: props.sortDescriptor,\n    isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,\n    setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,\n    sort: function sort(columnKey, direction) {\n      var ref;\n      props.onSortChange({\n        column: columnKey,\n        direction: direction !== null && direction !== void 0 ? direction : ((ref = props.sortDescriptor) === null || ref === void 0 ? void 0 : ref.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : 'ascending'\n      });\n    }\n  };\n}\nfunction $312ae3b56a94a86e$var$TableHeader(props) {\n  return null;\n}\n$312ae3b56a94a86e$var$TableHeader.getCollectionNode = /*#__PURE__*/_regeneratorRuntime.mark(function getCollectionNode(props) {\n  var children, columns, _iterator7, _step7, column, _columns2;\n  return _regeneratorRuntime.wrap(function getCollectionNode$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        children = props.children, columns = props.columns;\n        if (!(typeof children === 'function')) {\n          _context2.next = 23;\n          break;\n        }\n        if (columns) {\n          _context2.next = 4;\n          break;\n        }\n        throw new Error('props.children was a function but props.columns is missing');\n      case 4:\n        _iterator7 = _createForOfIteratorHelper(columns);\n        _context2.prev = 5;\n        _iterator7.s();\n      case 7:\n        if ((_step7 = _iterator7.n()).done) {\n          _context2.next = 13;\n          break;\n        }\n        column = _step7.value;\n        _context2.next = 11;\n        return {\n          type: 'column',\n          value: column,\n          renderer: children\n        };\n      case 11:\n        _context2.next = 7;\n        break;\n      case 13:\n        _context2.next = 18;\n        break;\n      case 15:\n        _context2.prev = 15;\n        _context2.t0 = _context2[\"catch\"](5);\n        _iterator7.e(_context2.t0);\n      case 18:\n        _context2.prev = 18;\n        _iterator7.f();\n        return _context2.finish(18);\n      case 21:\n        _context2.next = 26;\n        break;\n      case 23:\n        _columns2 = [];\n        $1BfjW$react.Children.forEach(children, function (column) {\n          _columns2.push({\n            type: 'column',\n            element: column\n          });\n        });\n        return _context2.delegateYield(_columns2, \"t1\", 26);\n      case 26:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, getCollectionNode, null, [[5, 15, 18, 21]]);\n});\n/**\n * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `columns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nvar $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;\nfunction $4ae5314bf50db1a3$var$TableBody(props) {\n  return null;\n}\n$4ae5314bf50db1a3$var$TableBody.getCollectionNode = /*#__PURE__*/_regeneratorRuntime.mark(function getCollectionNode(props) {\n  var children, items1;\n  return _regeneratorRuntime.wrap(function getCollectionNode$(_context4) {\n    while (1) switch (_context4.prev = _context4.next) {\n      case 0:\n        children = props.children, items1 = props.items;\n        _context4.next = 3;\n        return {\n          type: 'body',\n          hasChildNodes: true,\n          props: props,\n          childNodes: /*#__PURE__*/_regeneratorRuntime.mark(function childNodes() {\n            var _iterator8, _step8, item, items;\n            return _regeneratorRuntime.wrap(function childNodes$(_context3) {\n              while (1) switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (!(typeof children === 'function')) {\n                    _context3.next = 22;\n                    break;\n                  }\n                  if (items1) {\n                    _context3.next = 3;\n                    break;\n                  }\n                  throw new Error('props.children was a function but props.items is missing');\n                case 3:\n                  _iterator8 = _createForOfIteratorHelper(items1);\n                  _context3.prev = 4;\n                  _iterator8.s();\n                case 6:\n                  if ((_step8 = _iterator8.n()).done) {\n                    _context3.next = 12;\n                    break;\n                  }\n                  item = _step8.value;\n                  _context3.next = 10;\n                  return {\n                    type: 'item',\n                    value: item,\n                    renderer: children\n                  };\n                case 10:\n                  _context3.next = 6;\n                  break;\n                case 12:\n                  _context3.next = 17;\n                  break;\n                case 14:\n                  _context3.prev = 14;\n                  _context3.t0 = _context3[\"catch\"](4);\n                  _iterator8.e(_context3.t0);\n                case 17:\n                  _context3.prev = 17;\n                  _iterator8.f();\n                  return _context3.finish(17);\n                case 20:\n                  _context3.next = 25;\n                  break;\n                case 22:\n                  items = [];\n                  $1BfjW$react.Children.forEach(children, function (item) {\n                    items.push({\n                      type: 'item',\n                      element: item\n                    });\n                  });\n                  return _context3.delegateYield(items, \"t1\", 25);\n                case 25:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }, childNodes, null, [[4, 14, 17, 20]]);\n          })\n        };\n      case 3:\n      case \"end\":\n        return _context4.stop();\n    }\n  }, getCollectionNode);\n});\n/**\n * A TableBody is a container for the Row elements of a Table. Rows can be statically defined\n * as children, or generated dynamically using a function based on the data passed to the `items` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nvar $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;\nfunction $1cd244557c2f97d5$var$Column(props) {\n  return null;\n}\n$1cd244557c2f97d5$var$Column.getCollectionNode = /*#__PURE__*/_regeneratorRuntime.mark(function getCollectionNode(props, context1) {\n  var title, children, childColumns1, rendered, textValue, fullNodes, updateContext;\n  return _regeneratorRuntime.wrap(function getCollectionNode$(_context6) {\n    while (1) switch (_context6.prev = _context6.next) {\n      case 0:\n        title = props.title, children = props.children, childColumns1 = props.childColumns;\n        rendered = title || children;\n        textValue = props.textValue || (typeof rendered === 'string' ? rendered : '') || props['aria-label'];\n        _context6.next = 5;\n        return {\n          type: 'column',\n          hasChildNodes: !!childColumns1 || title && $1BfjW$react.Children.count(children) > 0,\n          rendered: rendered,\n          textValue: textValue,\n          props: props,\n          childNodes: /*#__PURE__*/_regeneratorRuntime.mark(function childNodes() {\n            var _iterator9, _step9, child1, childColumns;\n            return _regeneratorRuntime.wrap(function childNodes$(_context5) {\n              while (1) switch (_context5.prev = _context5.next) {\n                case 0:\n                  if (!childColumns1) {\n                    _context5.next = 20;\n                    break;\n                  }\n                  _iterator9 = _createForOfIteratorHelper(childColumns1);\n                  _context5.prev = 2;\n                  _iterator9.s();\n                case 4:\n                  if ((_step9 = _iterator9.n()).done) {\n                    _context5.next = 10;\n                    break;\n                  }\n                  child1 = _step9.value;\n                  _context5.next = 8;\n                  return {\n                    type: 'column',\n                    value: child1\n                  };\n                case 8:\n                  _context5.next = 4;\n                  break;\n                case 10:\n                  _context5.next = 15;\n                  break;\n                case 12:\n                  _context5.prev = 12;\n                  _context5.t0 = _context5[\"catch\"](2);\n                  _iterator9.e(_context5.t0);\n                case 15:\n                  _context5.prev = 15;\n                  _iterator9.f();\n                  return _context5.finish(15);\n                case 18:\n                  _context5.next = 24;\n                  break;\n                case 20:\n                  if (!title) {\n                    _context5.next = 24;\n                    break;\n                  }\n                  childColumns = [];\n                  $1BfjW$react.Children.forEach(children, function (child) {\n                    childColumns.push({\n                      type: 'column',\n                      element: child\n                    });\n                  });\n                  return _context5.delegateYield(childColumns, \"t1\", 24);\n                case 24:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }, childNodes, null, [[2, 12, 15, 18]]);\n          }),\n          shouldInvalidate: function shouldInvalidate(newContext) {\n            // This is a bit of a hack, but it works.\n            // If this method is called, then there's a cached version of this node available.\n            // But, we need to keep the list of columns in the new context up to date.\n            updateContext(newContext);\n            return false;\n          }\n        };\n      case 5:\n        fullNodes = _context6.sent;\n        updateContext = function updateContext(context) {\n          // register leaf columns on the context so that <Row> can access them\n          var _iterator10 = _createForOfIteratorHelper(fullNodes),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var node = _step10.value;\n              if (!node.hasChildNodes) context.columns.push(node);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        };\n        updateContext(context1);\n      case 8:\n      case \"end\":\n        return _context6.stop();\n    }\n  }, getCollectionNode);\n});\n/**\n * A Column represents a field of each item within a Table. Columns may also contain nested\n * Column elements to represent column groups. Nested columns can be statically defined as\n * children, or dynamically generated using a function based on the `childColumns` prop.\n */ // We don't want getCollectionNode to show up in the type definition\nvar $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;\nfunction $70d70eb16ea48428$var$Row(props) {\n  return null;\n}\n$70d70eb16ea48428$var$Row.getCollectionNode = /*#__PURE__*/_regeneratorRuntime.mark(function getCollectionNode(props, context) {\n  var children, textValue;\n  return _regeneratorRuntime.wrap(function getCollectionNode$(_context8) {\n    while (1) switch (_context8.prev = _context8.next) {\n      case 0:\n        children = props.children, textValue = props.textValue;\n        _context8.next = 3;\n        return {\n          type: 'item',\n          props: props,\n          textValue: textValue,\n          'aria-label': props['aria-label'],\n          hasChildNodes: true,\n          childNodes: /*#__PURE__*/_regeneratorRuntime.mark(function childNodes() {\n            var _iterator11, _step11, column, cells;\n            return _regeneratorRuntime.wrap(function childNodes$(_context7) {\n              while (1) switch (_context7.prev = _context7.next) {\n                case 0:\n                  if (!(context.showSelectionCheckboxes && context.selectionMode !== 'none')) {\n                    _context7.next = 3;\n                    break;\n                  }\n                  _context7.next = 3;\n                  return {\n                    type: 'cell',\n                    key: 'header',\n                    props: {\n                      isSelectionCell: true\n                    }\n                  };\n                case 3:\n                  if (!(typeof children === 'function')) {\n                    _context7.next = 23;\n                    break;\n                  }\n                  _iterator11 = _createForOfIteratorHelper(context.columns);\n                  _context7.prev = 5;\n                  _iterator11.s();\n                case 7:\n                  if ((_step11 = _iterator11.n()).done) {\n                    _context7.next = 13;\n                    break;\n                  }\n                  column = _step11.value;\n                  _context7.next = 11;\n                  return {\n                    type: 'cell',\n                    element: children(column.key),\n                    key: column.key // this is combined with the row key by CollectionBuilder\n                  };\n                case 11:\n                  _context7.next = 7;\n                  break;\n                case 13:\n                  _context7.next = 18;\n                  break;\n                case 15:\n                  _context7.prev = 15;\n                  _context7.t0 = _context7[\"catch\"](5);\n                  _iterator11.e(_context7.t0);\n                case 18:\n                  _context7.prev = 18;\n                  _iterator11.f();\n                  return _context7.finish(18);\n                case 21:\n                  _context7.next = 28;\n                  break;\n                case 23:\n                  cells = [];\n                  $1BfjW$react.Children.forEach(children, function (cell) {\n                    cells.push({\n                      type: 'cell',\n                      element: cell\n                    });\n                  });\n                  if (!(cells.length !== context.columns.length)) {\n                    _context7.next = 27;\n                    break;\n                  }\n                  throw new Error(\"Cell count must match column count. Found \".concat(cells.length, \" cells and \").concat(context.columns.length, \" columns.\"));\n                case 27:\n                  return _context7.delegateYield(cells, \"t1\", 28);\n                case 28:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }, childNodes, null, [[5, 15, 18, 21]]);\n          }),\n          shouldInvalidate: function shouldInvalidate(newContext) {\n            // Invalidate all rows if the columns changed.\n            return newContext.columns.length !== context.columns.length || newContext.columns.some(function (c, i) {\n              return c.key !== context.columns[i].key;\n            }) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.selectionMode !== context.selectionMode;\n          }\n        };\n      case 3:\n      case \"end\":\n        return _context8.stop();\n    }\n  }, getCollectionNode);\n});\n/**\n * A Row represents a single item in a Table and contains Cell elements for each column.\n * Cells can be statically defined as children, or generated dynamically using a function\n * based on the columns defined in the TableHeader.\n */ // We don't want getCollectionNode to show up in the type definition\nvar $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;\nfunction $941d1d9a6a28982a$var$Cell(props) {\n  return null;\n}\n$941d1d9a6a28982a$var$Cell.getCollectionNode = /*#__PURE__*/_regeneratorRuntime.mark(function getCollectionNode(props) {\n  var children, textValue;\n  return _regeneratorRuntime.wrap(function getCollectionNode$(_context9) {\n    while (1) switch (_context9.prev = _context9.next) {\n      case 0:\n        children = props.children;\n        textValue = props.textValue || (typeof children === 'string' ? children : '') || props['aria-label'] || '';\n        _context9.next = 4;\n        return {\n          type: 'cell',\n          props: props,\n          rendered: children,\n          textValue: textValue,\n          'aria-label': props['aria-label'],\n          hasChildNodes: false\n        };\n      case 4:\n      case \"end\":\n        return _context9.stop();\n    }\n  }, getCollectionNode);\n});\n/**\n * A Cell represents the value of a single Column within a Table Row.\n */ // We don't want getCollectionNode to show up in the type definition\nvar $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;\nexport { $292bc4e09cd0eb62$export$cb895dcf85db1319 as useTableColumnResizeState, $4a0dd036d492cee4$export$907bcc6c48325fd6 as useTableState, $312ae3b56a94a86e$export$f850895b287ef28e as TableHeader, $4ae5314bf50db1a3$export$76ccd210b9029917 as TableBody, $1cd244557c2f97d5$export$816b5d811295e6bc as Column, $70d70eb16ea48428$export$b59bdbef9ce70de2 as Row, $941d1d9a6a28982a$export$f6f0c3fe4ec306ea as Cell, $6555104ff085bef4$re_export$Section as Section };","map":null,"metadata":{},"sourceType":"module"}