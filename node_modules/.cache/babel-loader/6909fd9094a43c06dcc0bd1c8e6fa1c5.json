{"ast":null,"code":"import _regeneratorRuntime from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"F:\\\\Ecommerce_recommendation_system\\\\Ecom_rec_system\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { useReducer as $d70Aq$useReducer, useEffect as $d70Aq$useEffect, useState as $d70Aq$useState, useMemo as $d70Aq$useMemo } from \"react\";\nfunction $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {\n  var _options$initialItems = options.initialItems,\n    initialItems = _options$initialItems === void 0 ? [] : _options$initialItems,\n    initialSelectedKeys = options.initialSelectedKeys,\n    _options$getKey = options.getKey,\n    getKey = _options$getKey === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey,\n    filter = options.filter,\n    _options$initialFilte = options.initialFilterText,\n    initialFilterText = _options$initialFilte === void 0 ? '' : _options$initialFilte; // Store both items and filteredItems in state so we can go back to the unfiltered list\n  var _$d70Aq$useState = $d70Aq$useState({\n      items: initialItems,\n      selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n      filterText: initialFilterText\n    }),\n    _$d70Aq$useState2 = _slicedToArray(_$d70Aq$useState, 2),\n    state = _$d70Aq$useState2[0],\n    setState = _$d70Aq$useState2[1];\n  var filteredItems = $d70Aq$useMemo(function () {\n    return filter ? state.items.filter(function (item) {\n      return filter(item, state.filterText);\n    }) : state.items;\n  }, [state.items, state.filterText, filter]);\n  return _objectSpread({}, state, {\n    items: filteredItems\n  }, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n    getKey: getKey\n  }, setState), {\n    getItem: function getItem(key) {\n      return state.items.find(function (item) {\n        return getKey(item) === key;\n      });\n    }\n  });\n}\nfunction $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {\n  var cursor = opts.cursor,\n    getKey = opts.getKey;\n  return {\n    setSelectedKeys: function setSelectedKeys(selectedKeys) {\n      dispatch(function (state) {\n        return _objectSpread({}, state, {\n          selectedKeys: selectedKeys\n        });\n      });\n    },\n    setFilterText: function setFilterText(filterText) {\n      dispatch(function (state) {\n        return _objectSpread({}, state, {\n          filterText: filterText\n        });\n      });\n    },\n    insert: function insert(index) {\n      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        values[_key - 1] = arguments[_key];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index].concat(values));\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index].concat(values));\n      });\n    },\n    insertAfter: function insertAfter(key) {\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index + 1].concat(values));\n      });\n    },\n    prepend: function prepend() {\n      for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        values[_key4] = arguments[_key4];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, 0].concat(values));\n      });\n    },\n    append: function append() {\n      for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        values[_key5] = arguments[_key5];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, state.items.length].concat(values));\n      });\n    },\n    remove: function remove() {\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n      dispatch(function (state) {\n        var keySet = new Set(keys);\n        var items = state.items.filter(function (item) {\n          return !keySet.has(getKey(item));\n        });\n        var selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n            var key = _keys[_i];\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) selection = new Set();\n        return _objectSpread({}, state, {\n          items: items,\n          selectedKeys: selection\n        });\n      });\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      dispatch(function (state) {\n        if (state.selectedKeys === 'all') return _objectSpread({}, state, {\n          items: [],\n          selectedKeys: new Set()\n        });\n        var selectedKeys = state.selectedKeys;\n        var items = state.items.filter(function (item) {\n          return !selectedKeys.has(getKey(item));\n        });\n        return _objectSpread({}, state, {\n          items: items,\n          selectedKeys: new Set()\n        });\n      });\n    },\n    move: function move(key, toIndex) {\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return state;\n        var copy = state.items.slice();\n        var _copy$splice = copy.splice(index, 1),\n          _copy$splice2 = _slicedToArray(_copy$splice, 1),\n          item1 = _copy$splice2[0];\n        copy.splice(toIndex, 0, item1);\n        return _objectSpread({}, state, {\n          items: copy\n        });\n      });\n    },\n    moveBefore: function moveBefore(key1, keys) {\n      dispatch(function (state) {\n        var toIndex = state.items.findIndex(function (item) {\n          return getKey(item) === key1;\n        });\n        if (toIndex === -1) return state;\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        var keyArray = Array.isArray(keys) ? keys : _toConsumableArray(keys);\n        var indices = keyArray.map(function (key) {\n          return state.items.findIndex(function (item) {\n            return getKey(item) === key;\n          });\n        }).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);\n      });\n    },\n    moveAfter: function moveAfter(key2, keys) {\n      dispatch(function (state) {\n        var toIndex = state.items.findIndex(function (item) {\n          return getKey(item) === key2;\n        });\n        if (toIndex === -1) return state;\n        var keyArray = Array.isArray(keys) ? keys : _toConsumableArray(keys);\n        var indices = keyArray.map(function (key) {\n          return state.items.findIndex(function (item) {\n            return getKey(item) === key;\n          });\n        }).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);\n      });\n    },\n    update: function update(key, newValue) {\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return state;\n        return _objectSpread({}, state, {\n          items: [].concat(_toConsumableArray(state.items.slice(0, index)), [newValue], _toConsumableArray(state.items.slice(index + 1)))\n        });\n      });\n    }\n  };\n}\nfunction $0d86e9c8f07f9a7b$var$insert(state, index) {\n  for (var _len7 = arguments.length, values = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n    values[_key7 - 2] = arguments[_key7];\n  }\n  return _objectSpread({}, state, {\n    items: [].concat(_toConsumableArray(state.items.slice(0, index)), values, _toConsumableArray(state.items.slice(index)))\n  });\n}\nfunction $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {\n  // Shift the target down by the number of items being moved from before the target\n  var _iterator = _createForOfIteratorHelper(indices),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var index = _step.value;\n      if (index < toIndex) toIndex--;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var moves = indices.map(function (from) {\n    return {\n      from: from,\n      to: toIndex++\n    };\n  });\n  // Shift later from indices down if they have a larger index\n  for (var i = 0; i < moves.length; i++) {\n    var a = moves[i].from;\n    for (var j = i; j < moves.length; j++) {\n      var b = moves[j].from;\n      if (b > a) moves[j].from--;\n    }\n  }\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (var i1 = 0; i1 < moves.length; i1++) {\n    var _a = moves[i1];\n    for (var _j = moves.length - 1; _j > i1; _j--) {\n      var _b = moves[_j];\n      if (_b.from < _a.to) _a.to++;else _b.from++;\n    }\n  }\n  var copy = state.items.slice();\n  var _iterator2 = _createForOfIteratorHelper(moves),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var move = _step2.value;\n      var _copy$splice3 = copy.splice(move.from, 1),\n        _copy$splice4 = _slicedToArray(_copy$splice3, 1),\n        item = _copy$splice4[0];\n      copy.splice(move.to, 0, item);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return _objectSpread({}, state, {\n    items: copy\n  });\n}\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n  var selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          var _filterText, _sortDescriptor;\n          return _objectSpread({}, data, {\n            filterText: (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n            abortController: action.abortController\n          });\n        case 'update':\n          return _objectSpread({}, data, action.updater(data));\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) return data;\n          var _selectedKeys;\n          selectedKeys = (_selectedKeys = action.selectedKeys) !== null && _selectedKeys !== void 0 ? _selectedKeys : data.selectedKeys;\n          var _filterText1, _sortDescriptor1;\n          return _objectSpread({}, data, {\n            filterText: (_filterText1 = action.filterText) !== null && _filterText1 !== void 0 ? _filterText1 : data.filterText,\n            state: 'idle',\n            items: _toConsumableArray(action.items),\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: (_sortDescriptor1 = action.sortDescriptor) !== null && _sortDescriptor1 !== void 0 ? _sortDescriptor1 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread({}, data, {\n            state: 'error',\n            error: action.error,\n            abortController: null\n          });\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          var _filterText2;\n          return _objectSpread({}, data, {\n            filterText: (_filterText2 = action.filterText) !== null && _filterText2 !== void 0 ? _filterText2 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return _objectSpread({}, data, action.updater(data));\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          var _selectedKeys1;\n          selectedKeys = data.selectedKeys === 'all' || action.selectedKeys === 'all' ? 'all' : new Set([].concat(_toConsumableArray(data.selectedKeys), _toConsumableArray((_selectedKeys1 = action.selectedKeys) !== null && _selectedKeys1 !== void 0 ? _selectedKeys1 : [])));\n          var _sortDescriptor2;\n          // Append the new items\n          return _objectSpread({}, data, {\n            state: 'idle',\n            items: [].concat(_toConsumableArray(data.items), _toConsumableArray(action.items)),\n            selectedKeys: selectedKeys,\n            sortDescriptor: (_sortDescriptor2 = action.sortDescriptor) !== null && _sortDescriptor2 !== void 0 ? _sortDescriptor2 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread({}, data, {\n            state: 'error',\n            error: action.error\n          });\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          var _filterText3;\n          return _objectSpread({}, data, {\n            filterText: (_filterText3 = action.filterText) !== null && _filterText3 !== void 0 ? _filterText3 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return _objectSpread({}, data, action.updater(data));\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    default:\n      throw new Error(\"Invalid state \\\"\".concat(data.state, \"\\\"\"));\n  }\n}\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n  var load = options.load,\n    _sort = options.sort,\n    initialSelectedKeys = options.initialSelectedKeys,\n    initialSortDescriptor = options.initialSortDescriptor,\n    _options$getKey2 = options.getKey,\n    getKey = _options$getKey2 === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey2,\n    _options$initialFilte2 = options.initialFilterText,\n    initialFilterText = _options$initialFilte2 === void 0 ? '' : _options$initialFilte2;\n  var _$d70Aq$useReducer = $d70Aq$useReducer($f86e6c1ec7da6ebb$var$reducer, {\n      state: 'idle',\n      error: null,\n      items: [],\n      selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n      sortDescriptor: initialSortDescriptor,\n      filterText: initialFilterText\n    }),\n    _$d70Aq$useReducer2 = _slicedToArray(_$d70Aq$useReducer, 2),\n    data = _$d70Aq$useReducer2[0],\n    dispatch = _$d70Aq$useReducer2[1];\n  var dispatchFetch = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(action, fn) {\n      var abortController, _filterText, previousFilterText, _sortDescriptor, response, _filterText4, filterText;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            abortController = new AbortController();\n            _context.prev = 1;\n            dispatch(_objectSpread({}, action, {\n              abortController: abortController\n            }));\n            previousFilterText = (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText;\n            _context.next = 6;\n            return fn({\n              items: data.items.slice(),\n              selectedKeys: data.selectedKeys,\n              sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n              signal: abortController.signal,\n              cursor: action.type === 'loadingMore' ? data.cursor : null,\n              filterText: previousFilterText\n            });\n          case 6:\n            response = _context.sent;\n            filterText = (_filterText4 = response.filterText) !== null && _filterText4 !== void 0 ? _filterText4 : previousFilterText;\n            dispatch(_objectSpread({\n              type: 'success'\n            }, response, {\n              abortController: abortController\n            }));\n            // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n            // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n            if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n              type: 'filtering',\n              filterText: filterText\n            }, load);\n            _context.next = 15;\n            break;\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context[\"catch\"](1);\n            dispatch({\n              type: 'error',\n              error: _context.t0,\n              abortController: abortController\n            });\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[1, 12]]);\n    }));\n    return function dispatchFetch(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  $d70Aq$useEffect(function () {\n    dispatchFetch({\n      type: 'loading'\n    }, load);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return _objectSpread({\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem: function getItem(key) {\n      return data.items.find(function (item) {\n        return getKey(item) === key;\n      });\n    },\n    reload: function reload() {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n    },\n    loadMore: function loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;\n      dispatchFetch({\n        type: 'loadingMore'\n      }, load);\n    },\n    sort: function sort(sortDescriptor) {\n      dispatchFetch({\n        type: 'sorting',\n        sortDescriptor: sortDescriptor\n      }, _sort || load);\n    }\n  }, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(_objectSpread({}, options, {\n    getKey: getKey,\n    cursor: data.cursor\n  }), function (fn) {\n    dispatch({\n      type: 'update',\n      updater: fn\n    });\n  }), {\n    setFilterText: function setFilterText(filterText) {\n      dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    }\n  });\n}\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  var _options$initialItems2 = options.initialItems,\n    initialItems1 = _options$initialItems2 === void 0 ? [] : _options$initialItems2,\n    initialSelectedKeys = options.initialSelectedKeys,\n    _options$getKey3 = options.getKey,\n    getKey = _options$getKey3 === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey3,\n    _options$getChildren = options.getChildren,\n    getChildren = _options$getChildren === void 0 ? function (item) {\n      return item.children;\n    } : _options$getChildren;\n  var map = $d70Aq$useMemo(function () {\n    return new Map();\n  }, []);\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  var initialNodes = $d70Aq$useMemo(function () {\n    return buildTree(initialItems1);\n  }, []);\n  var _$d70Aq$useState3 = $d70Aq$useState(initialNodes),\n    _$d70Aq$useState4 = _slicedToArray(_$d70Aq$useState3, 2),\n    items1 = _$d70Aq$useState4[0],\n    setItems = _$d70Aq$useState4[1];\n  var _$d70Aq$useState5 = $d70Aq$useState(new Set(initialSelectedKeys || [])),\n    _$d70Aq$useState6 = _slicedToArray(_$d70Aq$useState5, 2),\n    selectedKeys = _$d70Aq$useState6[0],\n    setSelectedKeys = _$d70Aq$useState6[1];\n  function buildTree() {\n    var initialItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var parentKey = arguments.length > 1 ? arguments[1] : undefined;\n    return initialItems.map(function (item) {\n      var node = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n  function updateTree(items, key, update) {\n    var node = map.get(key);\n    if (!node) return items;\n    // Create a new node. If null, then delete the node, otherwise replace.\n    var newNode = update(node);\n    if (newNode == null) deleteNode(node);else addNode(newNode);\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      var nextParent = map.get(node.parentKey);\n      var copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      var children = nextParent.children;\n      if (newNode == null) children = children.filter(function (c) {\n        return c !== node;\n      });\n      copy.children = children.map(function (child) {\n        if (child === node) return newNode;\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n    if (newNode == null) items = items.filter(function (c) {\n      return c !== node;\n    });\n    return items.map(function (item) {\n      if (item === node) return newNode;\n      return item;\n    });\n  }\n  function addNode(node) {\n    map.set(node.key, node);\n    var _iterator3 = _createForOfIteratorHelper(node.children),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var child = _step3.value;\n        addNode(child);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  function deleteNode(node) {\n    map.delete(node.key);\n    var _iterator4 = _createForOfIteratorHelper(node.children),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var child = _step4.value;\n        deleteNode(child);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  return {\n    items: items1,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem: function getItem(key) {\n      return map.get(key);\n    },\n    insert: function insert(parentKey, index) {\n      for (var _len8 = arguments.length, values = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n        values[_key8 - 2] = arguments[_key8];\n      }\n      setItems(function (items) {\n        var nodes = buildTree(values, parentKey);\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) return [].concat(_toConsumableArray(items.slice(0, index)), _toConsumableArray(nodes), _toConsumableArray(items.slice(index)));\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), _toConsumableArray(nodes), _toConsumableArray(parentNode.children.slice(index)))\n          };\n        });\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      var node = map.get(key);\n      if (!node) return;\n      var parentNode = map.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items1;\n      var index = nodes.indexOf(node);\n      for (var _len9 = arguments.length, values = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n        values[_key9 - 1] = arguments[_key9];\n      }\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index].concat(values));\n    },\n    insertAfter: function insertAfter(key) {\n      var node = map.get(key);\n      if (!node) return;\n      var parentNode = map.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items1;\n      var index = nodes.indexOf(node);\n      for (var _len10 = arguments.length, values = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n        values[_key10 - 1] = arguments[_key10];\n      }\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1].concat(values));\n    },\n    prepend: function prepend(parentKey) {\n      for (var _len11 = arguments.length, values = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n        values[_key11 - 1] = arguments[_key11];\n      }\n      this.insert.apply(this, [parentKey, 0].concat(values));\n    },\n    append: function append(parentKey) {\n      for (var _len12 = arguments.length, values = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n        values[_key12 - 1] = arguments[_key12];\n      }\n      if (parentKey == null) this.insert.apply(this, [null, items1.length].concat(values));else {\n        var parentNode = map.get(parentKey);\n        if (!parentNode) return;\n        this.insert.apply(this, [parentKey, parentNode.children.length].concat(values));\n      }\n    },\n    remove: function remove() {\n      var newItems = items1;\n      for (var _len13 = arguments.length, keys = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        keys[_key13] = arguments[_key13];\n      }\n      for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {\n        var key = _keys2[_i2];\n        newItems = updateTree(newItems, key, function () {\n          return null;\n        });\n      }\n      setItems(newItems);\n      var selection = new Set(selectedKeys);\n      var _iterator5 = _createForOfIteratorHelper(selectedKeys),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var key1 = _step5.value;\n          if (!map.has(key1)) selection.delete(key1);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      this.remove.apply(this, _toConsumableArray(selectedKeys));\n    },\n    move: function move(key, toParentKey, index) {\n      setItems(function (items) {\n        var node = map.get(key);\n        if (!node) return items;\n        items = updateTree(items, key, function () {\n          return null;\n        });\n        var movedNode = _objectSpread({}, node, {\n          parentKey: toParentKey\n        });\n        return updateTree(items, toParentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), [movedNode], _toConsumableArray(parentNode.children.slice(index)))\n          };\n        });\n      });\n    },\n    update: function update(oldKey, newValue) {\n      setItems(function (items) {\n        return updateTree(items, oldKey, function (oldNode) {\n          var node = {\n            key: oldNode.key,\n            parentKey: oldNode.parentKey,\n            value: newValue,\n            children: null\n          };\n          node.children = buildTree(getChildren(newValue), node.key);\n          return node;\n        });\n      });\n    }\n  };\n}\nexport { $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList, $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData, $0d86e9c8f07f9a7b$export$762f73dccccd255d as useListData };","map":null,"metadata":{},"sourceType":"module"}